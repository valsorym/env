package env

import (
	"fmt"
	"math"
	"strconv"
)

// strToInt64 convert string to int64 type. Returns: result, error.
// Returns default value for int64 type if value is empty.
func strToInt64(value string) (int64, error) {
	if len(value) == 0 {
		return 0, nil
	}

	return strconv.ParseInt(value, 10, 64)
}

// strToInt32 convert string to int32 type. Returns: result, error.
// Returns default value for int32 type if value is empty.
func strToInt32(value string) (int32, error) {
	r, err := strToInt64(value)
	if err != nil {
		return 0, err
	}

	if r >= math.MaxInt32 {
		return 0, fmt.Errorf("strToInt32: %d overflows int32", r)
	}

	return int32(r), err
}

// strToInt16 convert string to int16 type. Returns: result, error.
// Returns default value for int16 type if value is empty.
func strToInt16(value string) (int16, error) {
	r, err := strToInt64(value)
	if err != nil {
		return 0, err
	}

	if r >= math.MaxInt16 {
		return 0, fmt.Errorf("strToInt16: %d overflows int16", r)
	}

	return int16(r), err
}

// strToInt8 convert string to int8 type. Returns: result, error.
// Returns default value for int8 type if value is empty.
func strToInt8(value string) (int8, error) {
	r, err := strToInt64(value)
	if err != nil {
		return 0, err
	}

	if r >= math.MaxInt8 {
		return 0, fmt.Errorf("strToInt8: %d overflows int8", r)
	}

	return int8(r), err
}

// strToInt convert string to int type. Returns: result, error.
// Returns default value for int type if value is empty.
func strToInt(value string) (int, error) {
	r, err := strToInt64(value)
	if err != nil {
		return 0, err
	}

	// For 32-bit platform it is necessary to check overflow. Overflow for
	// 64-bit platform will be generated by the strToInt64 function.
	if strconv.IntSize == 32 && r >= math.MaxInt32 {
		return 0, fmt.Errorf("strToInt: %d overflows int (int32)", r)
	}

	return int(r), err
}

// strToUint64 convert string to uint64 type. Returns: result, error.
// Returns default value for uint64 type if value is empty.
func strToUint64(value string) (uint64, error) {
	if len(value) == 0 {
		return 0, nil
	}

	return strconv.ParseUint(value, 10, 64)
}

// strToUint32 convert string to uint32 type. Returns: result, error.
// Returns default value for uint32 type if value is empty.
func strToUint32(value string) (uint32, error) {
	r, err := strToUint64(value)
	if err != nil {
		return 0, err
	}

	if r >= math.MaxUint32 {
		return 0, fmt.Errorf("strToUint32: %d overflows uint32", r)
	}

	return uint32(r), err
}

// strToUint16 convert string to uint16 type. Returns: result, error.
// Returns default value for uint16 type if value is empty.
func strToUint16(value string) (uint16, error) {
	r, err := strToUint64(value)
	if err != nil {
		return 0, err
	}

	if r >= math.MaxUint16 {
		return 0, fmt.Errorf("strToUint16: %d overflows uint16", r)
	}

	return uint16(r), err
}

// strToInt8 convert string to int8 type. Returns: result, error.
// Returns default value for int8 type if value is empty.
func strToUint8(value string) (uint8, error) {
	r, err := strToUint64(value)
	if err != nil {
		return 0, err
	}

	if r >= math.MaxUint8 {
		return 0, fmt.Errorf("strToUint8: %d overflows uint8", r)
	}

	return uint8(r), err
}

// strToUint convert string to int type. Returns: result, error.
// Returns default value for uint type if value is empty.
func strToUint(value string) (uint, error) {
	r, err := strToUint64(value)
	if err != nil {
		return 0, err
	}

	// For 32-bit platform it is necessary to check overflow. Overflow for
	// 64-bit platform will be generated by the strToUint64 function.
	if strconv.IntSize == 32 && r >= math.MaxUint32 {
		return 0, fmt.Errorf("strToUint: %d overflows uint (uint32)", r)
	}

	return uint(r), err
}

// strToFloat64 convert string to float64 type. Returns: result, error.
// Returns default value for float64 type if value is empty.
func strToFloat64(value string) (float64, error) {
	if len(value) == 0 {
		return 0.0, nil
	}

	return strconv.ParseFloat(value, 64)
}

// strToFloat32 convert string to float32 type. Returns: result, error.
// Returns default value for float32 type if value is empty.
func strToFloat32(value string) (float32, error) {
	// Parse value from the environment.
	r, err := strToFloat64(value)
	if err != nil {
		return float32(r), err
	}

	if r > math.MaxFloat32 {
		return 0, fmt.Errorf("strToFloat32: %f overflows float32", r)
	}

	return float32(r), nil
}

// strToBool convert string to bool type. Returns: result, error.
// Returns default value for bool type if value is empty.
func strToBool(value string) (bool, error) {
	if len(value) == 0 {
		return false, nil
	}

	r, err := strconv.ParseBool(value)
	if err != nil {
		f, errF := strconv.ParseFloat(value, 64)
		if errF != nil {
			return r, err
		}

		if math.Abs(f) > 1e-9 {
			r = true
		}
	}

	return bool(r), nil
}
